\chapter{CSP and \ccsp} 
The Constraint Satisfaction Problem (CSP) is the problem of deciding if it is possible to
assign values to some variables such that given constraints are satisfied. \ccsp\ 
is the problem of finding the number of possible assignments for a set of constraints.
Consider the following example:

\begin{example}[\tcoloring]\label{exm:3col}
The problem \tcoloring\ is the problem of coloring vertices of the input graph \(G\)
with colors \(\setof{r,g,b}\) such that no two adjacent vertices are colored the same color.
This problem can be formulated with a set of constraints as follows.
Let \(V=\setof{v_1,v_2,\dotsc,v_n}\)
be a set of variables where each variable corresponds to a vertex of
the input graph \(G\)\@. The goal is to find a function
\(f:V\to \setof{r,g,b}\) such that for each edge \((u,v)\) of \(G\), \(f(u)\neq f(v)\) holds.
\end{example}

In the above example,
the CSP is the problem of deciding
if there is a function satisfying all the given constraints. \ccsp\ is the
problem of finding the number of such functions. Note that any CSP can then be expressed as 
deciding if the answer for \ccsp\ with the same set of constraints is greater zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let \(D\) be a set of elements; any subset of \(D^k\) is a \emph{relation} of arity \(k\) with
domain \(D\)\@. A \emph{constraint language} with domain \(D\) is a set of
relations with domain \(D\)\@.
In this work domains and relations are always finite.

A CSP instance \(\mathcal{P}\) with constraint language \mrelset\ is a tuple 
\((D,V,\conset)\) where:
\begin{itemize}
\item \(D\) is a set of values which is the domain of \mrelset,
\item \(V\) is a set of variables,
\item \mconset\ is a collection of constraints where each constraint consists of a scope \(\varrho\),
which is a tuple of variables from \(V\) and a relation \(R\) from \mrelset\
of the same arity as \(\varrho\)\@. A constraint is represented as \(\const{R, \varrho}\)\@.
\end{itemize}

An assignment for \(\mathcal{P}\) is a function \(\varphi\) from \(V\) to \(D\)\@. The assignment
\(\varphi\) is satisfying if the scope of each constraint is
mapped to a tuple of the corresponding relation.

\begin{defi}[CSP(\mrelset)]
For a fixed constraint language \mrelset, CSP(\mrelset) is the problem of deciding 
whether a CSP instance \(\mathcal{P}\) with constraint language \mrelset\
has a satisfying assignment.
\end{defi}

For a constraint language \mrelset\ that consists of only a single relation \(R\),
we use CSP(\(R)\) instead of CSP(\mrelset) for simplicity.

\begin{example}[\tcoloring]\label{exm:3colcsp}
We continue with the problem \tcoloring\ from Example~\ref{exm:3col}.
Let \mG\ be the input graph for the problem \tcoloring\@.
One way to formulate problem \tcoloring\ using a CSP(\mrelset) is as follows.
Let \(D=\setof{r,g,b}\) be the domain and \(NEQ_{rgb}\), the binary dis-equality relation on domain \(D\)\@, consists of all tuples from \(D^2\) except the ones whose elements are equal, that is
\[NEQ_{rgb}=\setof{(r,g),(r,b),(g,r),(g,b),(b,r), (b,g)}\]

Let \(\varphi\) be an assignment which is a function from vertices of \mG\ to \mD\@.
For each edge \((u,v)\) of \mG\, \(\varphi(u)\neq\varphi(v)\) holds which is
equivalent to \(NEQ_{rgb}(u,v)\)\@.

Let \mG\ be the graph in Figure~\ref{fig:sample}. The instance of 
CSP for \tcoloring\ on \mG\ is as follows. The set of variables is the set of vertices of \mG,
and for each edge of \mG\ a constraint with relation \(NEQ_{rgb}\) is placed.
\begin{align*}
\mathcal{P}=(&D=\setof{1,2,3},V=\setof{v_1,v_2,v_3,v_4,v_5}, \\
&\conset=\{\const{(v_1,v_2),NEQ_{rgb}}, \const{(v_2,v_3),NEQ_{rgb}},\const{(v_3,v_4),NEQ_{rgb}},\\
&\const{(v_4,v_5),NEQ_{rgb}}, \const{(v_5,v_1),NEQ_{rgb}},
\const{(v_2,v_3),NEQ_{rgb}}\})
\end{align*}
\end{example}

\begin{figure}
\centering
\input{figs/sample.pdftex}
\caption{Graph \ensuremath{G} used in Example~\ref{exm:3colcsp}}
\label{fig:sample}
\end{figure}

\begin{example}[\tsat]\label{exm:3sat}
The problem of deciding if there exists a truth assignment for a 
given Boolean CNF (Conjunctive Normal Form) formula where each
clause contains exactly 3 literals is called \tsat\@.

Let \(\relset_1=\setof{R_1,R_2,\dotsc, R_8}\) be a constraint language where:
\begin{itemize}
\item \(R_1=\{(x,y,z)\mid x,y,z\in \setof{T,F}, x \lor y \lor z = T\}\), 
\item \(R_2=\{(x,y,z)\mid x,y,z\in \setof{T,F}, \bar x \lor y \lor z = T\}\), 
\item \(R_3=\{(x,y,z)\mid x,y,z\in \setof{T,F}, x \lor \bar y \lor z = T\}\), 
\item \(R_4=\{(x,y,z)\mid x,y,z\in \setof{T,F}, x \lor y \lor \bar z = T\}\), 
\item \(R_5=\{(x,y,z)\mid x,y,z\in \setof{T,F}, \bar x \lor \bar y \lor z = T\}\), 
\item \(R_6=\{(x,y,z)\mid x,y,z\in \setof{T,F}, \bar x \lor y \lor \bar z = T\}\), 
\item \(R_7=\{(x,y,z)\mid x,y,z\in \setof{T,F}, x \lor \bar y \lor \bar z = T\}\), 
\item \(R_8=\{(x,y,z)\mid x,y,z\in \setof{T,F}, \bar x \lor \bar y \lor \bar z = T\}\)
\end{itemize}

Every clause in a \tsat\ instance can be expressed by a constraint using an \(R_i\) 
and vice-versa. Hence, there is a one-to-one correspondence between constraints 
in a CSP(\(\relset_1\)) instance and a \tsat\ instance. Hence,
the problems CSP(\(\relset_1\)) and the \tsat\ are the same.
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Another type of problems defined by constraint satisfaction are
counting problems which involve finding the number of solutions for a CSP instance.
The number of solutions of a CSP instance can be used to express many computational problems
such as partition functions which are mentioned in Section~\ref{sec:appl}.

\begin{defi}[\ccsp(\mrelset)] 
For a constraint language \mrelset,
\ccsp(\mrelset) is the problem of finding the number of satisfying assignments for a
given CSP instance with \mrelset\ as the constraint language.
\end{defi}

Here are two examples of counting problems which can be expressed as \ccsp(\mrelset) for some
constraint language \mrelset\@.
\begin{example}[\ctcol]
We continue with the \(NEQ_{rgb}\) relation from Example~\ref{exm:3colcsp}\@.
The problem of finding the number of 3-Colorings of a given graph denoted by 
\ctcol, can be expressed as the problem \ccsp(\(NEQ_{rgb}\)).
\end{example}

\begin{example}\label{exm:c3sat}
The problem of finding the number of satisfying truth assignments for a given 
Boolean CNF (Conjunctive Normal Form) formula where each clause contains exactly 3 literals
is called \ctsat\@. 

It is easy to see that with the constraint language \(\relset_1\) from Example~\ref{exm:3sat}
the problems \ctsat\ and the \ccsp(\(\relset_1\)) are the same.
\end{example} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Applications of \ccsp} \label{sec:appl}
In this section we will show several applications of \ccsp\ and how computational problems
can be formulated with \ccsp\@. First, we will describe a graph
homomorphism problem which can be viewed as a special case of CSP; next, we will relate
the number of homomorphisms between two graphs to the graph isomorphism problem.
We will also describe partition functions
and give examples of partition functions in two common models in statistical physics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Graph Homomorphism}
Let \mG\ and \mH\ be two graphs. A homomorphism from \mG\ to \mH\ is a mapping \(h\) of
vertices of \mG\ to vertices of \mH\ such that for every edge \((u,v)\) of \mG,
\((h(u),h(v))\) is an edge of \mH\@. If there is homomorphism from \mG\ to \mH\ 
we shall write \(G\to H\), and \(G \not\to H\) means that there is no homomorphism from
\mG\ to \mH\@.

\begin{example}\label{exm:hom}
Let \mG\ and \mH\ be the graphs shown in Figure~\ref{fig:hom}\@. The mapping \(h\)
defined as \(h(a)=1, h(b)=2, h(c)=3, h(d)=1\)
is not a homomorphism because \((a,d)\) is mapped to \((1,1)\) which is not an 
edge of \mH\ but the mapping \(h'\) defined as \(h'(a)=1, h'(b)=2, h'(c)=1, h'(d)=2\) 
is a homomorphism because all the edges of \mG\ are mapped to edges of \mH. 
Note that a homomorphism is not necessarily surjective.

\begin{figure}[h]
\center\input{figs/hom.pdftex}
\caption{Graph \ensuremath{m} and \ensuremath{H} used in Example~\ref{exm:hom}} \label{fig:hom}
\end{figure}
\end{example}

\begin{defi}[Hom(\mH)]
For a fixed graph \mH, Hom(\mH) is the problem of deciding whether a given graph \mG\
is homomorphic to \mH\@.
\end{defi}

\begin{example}[\tcoloring]
We continue with the problem \tcoloring\ from Example~\ref{exm:3col}; however, in this example 
we express it as a graph homomorphism problem. As usual we denote the complete graph
on \(k\) vertices by \(K_k\)\@. For all complete graphs, \((u,v)\) is an edge of \(K_k\)
if an only
if \(u\neq v\)\@. This shows that \(Hom(K_k)\) is the same as
the problem k-coloring. As a special case, \(\chom(K_3)\) is the same as problem \ctcol\@.
\end{example}

Let \pname{NoRB-3-Coloring} be the problem \pname{3-Coloring} with an additional
restriction that the vertices colored blue are not allowed to be connected 
to the vertices colored red. In order to formulate this problem with graph homomorphisms,
obtain \mH\ from \(K_3\) as follows. Label the vertices with \(\setof{r,g,b}\)\@.
Delete the edge between \(r\) and \(b\). The problem Hom(\mH) is the same as
the problem \pname{N0RB-3-Coloring}\@.
This example illustrates that the graph homomorphism problem generalizes the graph coloring problem.
This is why
the problem Hom(\mH) is also called the problem \pname{H-Coloring}\@.
More details and examples on graph homomorphism 
can be found in the book ~\cite{hellbook} by Hell and Ne\v{s}et\v{r}il.

\begin{obs}\label{obs:hom}
Let \mG\ and \mH\ be two graphs.
If \mH\ contains a loop (reflexive vertex) then \(G \to H\)\@.
If \mG\ is bipartite then \(G \to H\) if and only if \mH\ is has at least one edge.
If \mH\ is bipartite then \(G \to H\) if and only if \mG\ is bipartite.
\end{obs}

Observation~\ref{obs:hom} shows that if the graph \mH\ has a loop or is bipartite,
the problem Hom(\mH) is easy; however, for other graphs the problem is of higher complexity.

\begin{theorem} [Hell and Ne\v{s}et\v{r}il 1990~\cite{pavol}]
For an undirected graph \mH, the problem Hom(\mH) is polynomial time solvable if 
\mH\ contains a loop or \mH\ is bipartite; otherwise, it is NP-complete.
\end{theorem}

\begin{defi}[\chom(\mH)]
For a fixed graph \mH,
\chom(\mH) is the problem of finding the number of homomorphisms from a given 
input graph \mG\ to \mH.
\end{defi}

Dyer and Greenhill proved the following dichotomy for the problem \chom(\mH)\@.
\begin{theorem} [Dyer and Greenhill 2000 \cite{Dyer}]
For a graph \mH, if each component of \mH\ is either a reflexive complete graph
or a irreflexive complete bipartite graph then the problem \chom(\mH)
is polynomial time solvable; otherwise, it is \cpc\@.
\end{theorem}

Hom(\mH) and \chom(\mH) are special cases of CSP(\mrelset) and \ccsp(\mrelset),
respectively. In both cases, \mrelset\ consists of a single binary relation which is the
edge set of \mH\ with vertex set of \mH\ as the domain.
Hence, we may use Hom and \chom\ instead of
the corresponding CSP and \ccsp, respectively. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Lov\'{a}sz Vectors}
The number of homomorphisms from \mG\ to \mH\ is denoted by \(\hom(G,H)\); this function
can be used to define the \emph{Lov\'{a}sz vector} which is used to characterize graphs.
Lovasz \cite{lovasz} proved that
two graphs \(H_1\) and \(H_2\) are isomorphic if and only if for any graph \mG,
\(\hom(G,H_1)=\hom(G,H_2)\). 
For an enumeration of all non-isomorphic graphs \((G_1,G_2,\dotsc)\), 
the Lovasz vector of a graph \mH\ is the infinite sequence consisting of the number of
homomorphisms from graphs in the sequence to \mH, i.e.,
\((\hom(G_1,H), \hom(G_2,H), \dotsc)\)\@. 
In other words Lovasz's theorem indicates two graphs are isomorphic if and only if
they have the same Lovasz vector.  
\begin{comment}
Lov\'{a}sz and et al. \cite{propertytesting} used the Lov\'{a}sz vector
for \emph{Edge Reconstruction} problem over graphs with sufficiently many edges, 
They also used Lov\'{a}sz vector in the {\em Property Testing} area.
In this model there is usually a huge graph and at each step only small sample of vertices
can be examined. The goal is to infer parameters of the graph using small samples of it. 
A good example of such a graph one might want to find the properties is the Internet.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Sampling}
In this section, we use the model from \cite{JVV} for definition of classes of problems.
Let \(\Sigma\) be the finite alphabet used to encode input and output of a problem. 
We can express the assignment of a solution to an instance with a relation 
\(R \subseteq \Sigma^* \times \Sigma^*\)\@.

A \emph{uniform sampling} problem is a problem that for an instance \(x\),
generates a uniformly random solution \(y\) such that \((x,y) \in R\)\@.
An \emph{almost uniform sampling} is a problem that for an instance \(x\),
generates a random solution \(y\) 
such that \((x,y) \in R\) and for any other \(y'\) that \((x,y')\in R\) the 
probabilities of choosing \(y\) and \(y'\) are approximately the same.
Jerrum et al. \cite{JVV} explained that for practical purposes, it is impossible to distinguish
almost uniform sampling from uniform sampling by experiments running in polynomial time.
Hence, we may use them interchangeably in this work.

In this model a \emph{counting} problem is a problem that for an instance \(x\),
finds \(|\{y \mid (x,y) \in R\}|\) and an approximate counting
problem is a problem that for an instance \(x\), approximately 
finds \(|\{y \mid (x,y) \in R\}|\)\@.

Intuitively, a relation is said to be \emph{self-reducible} if solutions for an instance can be
expressed in terms of solutions for a number of smaller instances of the same relation.
Many of the relation such as the relation between a graph and a matching in that graph
and relation between CNF(Conjunctive Normal Form) or DNF(Disjunctive Normal Form) formula and
a satisfying truth assignment of that formula are self-reducible.

\begin{theorem} [Jerrum et al. 1986 \cite{JVV}] \label{thm:selfred}
For any self-reducible relation \mR, the almost uniform sampling problem and the approximate counting
problem have the same complexity.
\end{theorem}

Here we provide a very informal 
proof for the problem of finding the number of truth assignment for a CNF\@.
The general idea of the proof for Theorem~\ref{thm:selfred} is the same.
Let \(C\) be a CNF\@.
For a variable \(x\) used in \(C\), let \(C_x\) denote 
the CNF derived from \(C\) if \(x\) is assigned true; analogously, let \(C_{\bar x}\) denote
the CNF derived from \(C\) if \(x\) is assigned false. Clearly, the number of solutions for
\(C\) is the sum of the number of solutions for \(C_x\) and the number of solutions 
for \(C_{\bar x}\)\@.

In order to generate an almost uniform solution for \(C\) using an approximate counter,
we first approximately find the number of solutions for \(C_x\) and \(C_{\bar x}\)\@.
Next, we assign true or false to \(x\) with probability proportional to number of solutions 
for \(C\) and \(C_{\bar x}\)\@. Then, we continue
with \(C_x\) or \(C_{\bar x}\) regarding the choice in previous step.

In order to solve approximate counting using an almost uniform generator, we first
generate some number of random solutions. The number of solution we generate depends 
on the expected approximation ratio and the number of variables.
Let \(p(x)\) be the ratio of the number of solutions
where \(x\) is true to the total number of generated solutions; analogously, let \(p(\bar x)\) be
the ratio of number of solutions where \(x\) is false to the total number of generated solutions.
Without loss of generality, suppose that \(p(x) \ge p(\bar x)\)\@.
By recursion, estimate the number of solutions for \(C_x\). Finally, estimate 
the number of solutions for \(C\) by \(p(x)\) and the estimation for the 
number of solutions for \(C_x\)\@.

\subsection*{Partition Functions}
Let \mH\ be a graph.% For a given graph \mG, a configuration of \mG\ is a homomorphism 
%\(\sigma\) from \(V_G\) to
\(V_H\). For a weight function \(w: V_H \cup E_H\to \mathbb{R}\), the weight of the homomorphism 
\(h\) is defined as
\[w(h)=\prod_{uv\in E_G}w(h(u)h(v))\prod_{v\in V_G}w(h(v))\]
The partition function \(Z_H(G,w)\) is the sum of the weights for all the homomorphisms:
\[Z_H(G,w)=\sum_{h:G\to H}w(h)\]

Note that \(\hom(G,H)=Z_{H}(G,w)\) if \(w(v)=w(e)=1\) for all \(v,e\in H\)
and \(w(e)=0\) for all \(e\not\in H\)\@. 
The problem \pname{H-Partition} is defined as:

\pnndef%{\pname{H-Partition}}
{A graph \(G\) and a weight function \(w\)}
{The value of partition function \(Z_H(G,w)\)}


Given a weight function and the partition function, 
the \emph{Gibbs distribution} on homomorphisms from \mG\ to \mH\ is
the distribution that each homomorphism \(h\) has a probability 
\[\pi_{H,G,w}(h)=\frac{w(h)}{Z_H(G,w)}\]
The problem \pname{H-GibbsSample} is defined as:

\pnndef%{\pname{H-GibbsSample}}
{A graph \mG}
{An H-coloring of \mG\ chosen from distribution \(\pi_{H,G,w}\)}

Dyer et al. \cite{Sampling} have proved that if \pname{H-GibbsSample} can be approximately 
sampled in polynomial time then \pname{H-Partition} 
can also be approximated by a randomized algorithm in polynomial time. 
%The \chom(\mH) problem is not a self-reducible problem; however, it is very similar to
%self-reducible problems. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Statistical Mechanics}
Statistical Mechanics is a branch of physics that applies probability theory to
predict the behaviour of a system at a given temperature. Usually there is a complex system
consisting of many microscopic elements. A state or configuration \(\sigma\) is an assignment of
parameters of the microscopic elements. 
The \emph{Hamiltonian} \(H(\sigma)\) is the energy of the system in state \(\sigma\)\@. 
Let \(\beta\) be the inverse (one over) temperature. 
The \emph{Partition Function} at a given temperature is defined as
\[Z=\sum_\sigma e^{-\beta H(\sigma)}\]
Given a model of the system and the temperature,
many of the important properties of the system such as the free energy, the entropy, the specific heat, and the location of phase transition can be evaluate using the the partition function.

One of the commonly used models in Statistical Mechanics is the Ising model. In the Ising mode,
the system is defined by a graph \(G(V,E)\)\@.
Each edge of the graph \((u,v)\in E\) has an {\em interaction strength} \(J_{u,v}\)\@. Each
vertex has an associated \emph{local external magnetic field} \(l_v\)\@.
A configuration of the system  is an assignment \(\sigma: V\to \setof{-1,+1}\) of vertices of \mG\
to spins. Each configuration is associated with energy:
\[H(\sigma)=-\sum_{(u,v)\in E}J_{u,v}\cdot\sigma(u)\cdot\sigma(v)-\sum_{v\in V} l_v\cdot\sigma(v)\]
and the partition function for the Ising model is:
\begin{align*}
Z(G,\beta,J,l)&=\sum_{\sigma:V\to\setof{-1,+1}}e^{-\beta H(\sigma)}\\
&=\sum_{\sigma:V\to\setof{-1,+1}} \prod_{(u,v)\in E}
e^{\beta J_{u,v}\sigma(u)\sigma(v)} \prod_{v\in V} 
e^{\beta l_v\sigma(v)}
\end{align*}

To avoid exponentials in the notation, let \(\lambda_{u,v}=e^{2\beta J_{u,v}}\) and 
\(\mu_{v}=e^{2\beta l_v}\). The partition function will be:

\begin{align*}
Z(G,\lambda,\mu)&=\sum_{\sigma :V\to\setof{-1,+1}} \prod_{(u,v)\in E} \lambda_{u,v}^{\frac{1}{2}
\sigma(u)\sigma(v)}\prod_{v\in V}\mu_v^{\frac{1}{2}\sigma(v)}\\
&=\prod_{(u,v)\in E}\lambda_{u,v}^{-\frac{1}{2}}\prod_{v\in V}\mu_v^{-\frac{1}{2}}\sum_{\sigma:V\to
\setof{-1,+1}}
\prod_{(u,v)\in E}\lambda_{u,v}^{\frac{1}{2} + \frac{1}{2}\sigma(u)\sigma(v)}\prod_{v\in V:
}\mu_v^{\frac{1}{2} + \frac{1}{2}\sigma(v)} \\
&=\prod_{(u,v)\in E}\lambda_{u,v}^{-\frac{1}{2}}\prod_{v\in V}\mu_v^{-\frac{1}{2}}\sum_{\sigma:V\to
\setof{-1,+1}}
\prod_{\substack{(u,v)\in E \\ \sigma(u)=\sigma(v)}}\lambda_{u,v}\prod_{v\in V:
\sigma(v)=+1}\mu_v
\end{align*}

The system is \emph{ferromagnetic} if each interaction energy \(J_{u,v}\) is non-negative; 
which implies for all \(u,v\) in \(V\), we have \(\lambda_{u,v} \ge 1\)\@.
A system is \emph{consistent} if
either for all \(v\), \(\mu_v\ge 1\) or for all \(v\), \(\mu_v \le 1\)\@. We will
mention results on complexity of these cases in Chapter~\ref{chp:approx}\@.
%Jerrum and Sinclair \cite{Jer93} have proved that the problem of finding the partition
%function for the Ising model is hard to compute.

%Ashkin-Teller model generalizes the Ising model to four possible states.
The Potts model generalizes the Ising model to \(q\) possible spins.
In the Potts model there is an underlying graph \(G(V,E)\) and 
each configuration is an assignment \(\sigma:V\to \setof{\oneto{q}}\)\@.
Each edge of the graph \((u,v)\in E\) has an interaction
strength \(J_{u,v}\) and each vertex \(v\) at state \(c\) is associated with an
external field \(h_{v,c}\)\@. The energy of a configuration $\sigma$ is:
\[H(\sigma)=-\sum_{(u,v)\in E} J_{u,v}\chi(\sigma(u),\sigma(v)) - \sum_{v\in V} 
h_{v,\sigma(v)}\]
where
\[\chi(s,s')=\begin{cases}+1, & s=s'\\-1, & otherwise\end{cases}\]
As before, let \(\lambda_{u,v}=e^{2\beta J_{u,v}}\) and
\(\mu_{u,c}=e^{\beta h_{v,c}}\)\@. The partition function for the Potts model is:
\[Z(G,\lambda,\mu)=\prod_{(u,v)\in E}\lambda_{u,v}^{-\frac{1}{2}}
\sum_{\sigma:V\to\setof{\oneto q}} \prod_{(u,v)\in E:\sigma(u)=\sigma(v)}\lambda_{u,v}
\prod_{v\in V}\mu_{v,\sigma(v)}\]

Problems of computing partition functions in the Ising and Potts models can be
reduced to a \ccsp(\mrelset) for some constraint language \mrelset\@.
In Chapter~\ref{chp:approx}, we will mention results involving reductions from problems
of computing partition functions in the Ising and Potts models to problem \ccsp(\mrelset)\@.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reductions and Complexity of Counting}
In this chapter, we will mention several complexity classes for computational functions.
We will define clones and polymorphisms and specify how they are related to
the complexity of the problem CSP(\mrelset). We will mention the major results on the complexity of 
problem \ccsp(\mrelset). We will also define partial clones and specify
how they are related to the complexity of the problem \ccsp(\mrelset).

Two important classes of functions we are interested in are FP and \cp\@.
FP is the class of functions that are computable in polynomial time by a deterministic Turing machine
and \cp\ is the class of function that can be expressed as the
number of accepting paths of a non-deterministic polynomial time Turing machine. 

Let \(f,g:\Sigma^*\to\mathbb{N}\) be two functions. A \emph{parsimonious reduction}
from \mf\ to \mg\ is a polynomial time computable function
\(\sigma:\Sigma^*\to\Sigma^*\) such that
\(f(x)=g(\sigma(x))\) holds. 
A Turing reduction from \mf\ to \mg\ is an polynomial time algorithm
that computes \mf\ using an oracle of \mg\@.

\begin{defi}[\cpC ness] 
A problem \(f\) is \cpc\ if it is a member of \cp\ and every problem in \cp\ is 
Turing reducible to \(f\) in polynomial time.
\end{defi}

Consider the problems SAT and \csat\ defined as follows.
Note that the problems SAT and the \csat\ are generalizations of the problems \tsat\ and
the \ctsat\ mentioned in Examples~\ref{exm:3sat}~and~\ref{exm:c3sat}\@. 

\pdef{SAT}
{A CNF formula \(\varphi\)}
{Existence of a truth assignment that satisfies \(\varphi\)}

\pdef{\csat}
{A CNF formula \(\varphi\)}
{The number of truth assignments that satisfy \(\varphi\)}

In the same way that Cook \cite{cook1971} proved that SAT is NP-complete,
Valiant \cite{Valiant1979} showed that \csat\ is \cpc\@. 
The proof is easy; Valiant observed that the Cook's reduction from a non-deterministic Turing machine
to a SAT instance is a parsimonious reduction; hence, it works for counting problems, as well. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Clones}
In instances of CSP, constraints can be expressed either explicitly or implicitly by 
interactions of other constraints. Consider the following example.

\begin{example}
Let \(NEQ_{01}=\setof{(0,1),(1,0)}\) be a binary relation over the set
\(\setof{0,1}\)\@. Consider the following instance of 
CSP(\(NEQ_{01}\)) :
\[\mathcal{P}=(D=\setof{0,1},V=\setof{x,y,z},
 C=\setof{\const{NEQ_{01},(x,z)},\const{NEQ_{01}(y,z)}}\]
There is no explicit constraint with scope \((x,y)\)\@; however, there is the implicit 
constraint \(\const{EQV_{01},(x,y)}\) where \(EQV_{01}=\setof{(0,0),(1,1)}\)\@.
\end{example}

\begin{defi}[pp-definition]
Let \mrelset\ be a constraint language with domain \(D\) and 
let \(R\) be a relation with the same domain.
Relation \(R\) is said to be primitive positive (pp)-definable by \mrelset\
if \(R\) can be expressed as a predicate using relations from \mrelset,
the relation \(EQV_D\) which is the binary equality relation over \(D\),  conjunctions, and
existential quantification.
\end{defi}

\begin{example} \label{exm:ppd} 
Let \mrelset\ be a constraint language with domain \(D=\setof{a,b,c}\), 
consisting of a single relation 
\(R=\setof{(a,a,a),(b,b,b),(a,b,a),(a,b,c)}\)\@.
Relations 
\(R_1=\setof{a,b}\), 
\(R_2=\setof{(a,a),(b,b),(a,b)}\), 
and
\(R_3=\setof{(a,a,a),(a,a,c),(b,b,b)}\) are pp-definable by \mrelset\ as follows:
\begin{align*}
&R_1(x)=\exists z.R(x,x,z)\\
&R_2(x,y)=\exists z.R(x,y,z)\\
&R_3(x,y,z)=\exists s,t.R(x,t,z)\land R(z,s,y)
\end{align*}
\end{example}

The notion of  pp-definition is equivalent to elementary operators used in \cite{post41,bkkr69,lau},
and strict implementations used in \cite{madu,Trichotomy}\@.

A set of relations closed under pp-definition is called a \emph{co-clone}.
For a constraint language \mrelset, \(\clone{\relset}\) is the the least co-clone containing
\mrelset, also called the \emph{co-clone generated by \mrelset}\@.

A function \(f\) is said to be a \emph{projection} function if \(f(x_1,\dotsc,x_l)=x_l\) 
for some \(l\)\@.
A set of functions is said to be a \emph{clone} if it contains all projection
functions and is closed under superpositions (compositions). For a set of functions
\(C\), \(\clone{C}\) is the least clone containing \(C\) also called the clone generated by \(C\)\@.

A \emph{Galois connection} between sets \(A\) and \(B\) is a pair of functions
\(\fA:\pow{A} \to \pow{B}\) and \(\gB:\pow{B} \to \pow{A}\) 
which maintain {\em antitony}, that is,
\begin{align*}
\forall~X,X' \subseteq A: X \subseteq X' \implies \fA(X) \supseteq \fA(X') \\
\forall~Y,Y'\subseteq B: Y \subseteq Y' \implies \gB(Y) \supseteq \gB(Y') \\
\end{align*}
and {\em extensivity}, that is,
\begin{align*}
\forall~X\subseteq A:X \subseteq \gB(\fA(X)) \\
\forall~Y\subseteq B:Y \subseteq \fA(\gB(Y))
\end{align*}

Let \mR\ be a relation over domain \mD\ and \(f:D^n\to D\) a function of arity \mn\ over the
same domain. Function \mf\ \emph{preserves} \mR\ or is a \emph{polymorphism} of \mR\ if
for any \mn\ tuples \(\ba_1,\ba_2,\dotsc,\ba_n\) in \mR, the tuple
\(f(\ba_1,\ba_2,\dotsc,\ba_n)\) obtained by component-wise application of \mf,
is in \mR\@. The relation \mR\ in this case is said to be \emph{invariant} with respect 
to \mf\@.
The set of all functions preserving a constraint language \mrelset\ is 
denoted by \(Pol(\relset)\), the set of all relations invariant with respect to a set of
functions  \(C\) is denoted by \(Inv(C)\)\@.

Functions \(Inv\) and \(Pol\) satisfy antitony and extensivity; hence, they 
form a \emph{Galois connection} between the sets of functions 
and the set of relations, namely, we have the following theorem.

\begin{theorem}[Geiger \cite{gei68}, Romov et al. \cite{bkkr69}]
For any constraint language \mrelset\ and 
any set of functions \(C\), 
we have \(Inv(Pol(\relset))=\clone{\relset}\)
and
\(Pol(Inv(C))=\clone{C}\)
\@.
\end{theorem}

\begin{rem}
Since the \(Pol\) and \(Inv\) functions form a Galois connection, for any
constraint language \mrelset\ and any set of functions \(C\), 
\(Pol(\relset)\) and \(Inv(C)\) are co-clones and clones, respectively.
\end{rem}

\begin{cor}
Let \mrelset\ and \(\relset'\) be two constraint languages with the same domain.
If \(Pol(\relset) \subseteq Pol(\relset')\) then every relation from \(\relset'\)  is 
pp-definable in \mrelset\@.
\end{cor}

\begin{theorem} [Jeavons et al. 1997 \cite{Jeavons}] \label{trm:jeavons}
For a constraint language \mrelset\ and a relation \(R\) with the same domain,
if \mR\ is pp-definable in \mrelset\ then CSP(\mrelset) is polynomial-time equivalent 
to CSP(\(\relset \cup \setof R\))\@.
\end{theorem}

In order to reduce CSP(\(\relset \cup \setof R\)) to CSP(\mrelset),
for each instance \(\mathcal{P}=(D,V,C)\) of CSP(\(\relset \cup \setof R\)),
create an instance \(\mathcal{P}'=(D,V',C')\) of CSP(\mrelset) as follows.
Include all variables of \(V\) in \(V'\)\@.
For all relations \(R'\) in \mrelset, include constraints \(\const{R',\varrho}\) from \(C\)
in \(C'\)\@. For all constraints \(\const{R,\varrho}\) in \(C\), we use \(\psi\)
the pp-definition of \mR\ in \mrelset\ to replace \mR\ in \(\mathcal{P}'\);
for each existential quantifier in \(\psi\), add the quantified variables to \(V'\);
for each \(EQV_D(x,y)\) relation in \(\psi\), replace all occurrences of \(y\) with \(x\);
the rest of \(\psi\) consists of conjunction of clauses in the form \(R'(\varrho)\) where
\(R'\) is a relation in \mrelset\ and \(\varrho\) is a scope of variables from \(V'\);
for each clause \(R'(\varrho)\) in \(\psi\), add a constraint \(\const{R',\varrho}\) to \(C'\)\@.
For each satisfying assignment \(\varphi\) of \(\mathcal{P'}\),
the restriction of \(\varphi\) to \(V\) is a satisfying assignment for \(\mathcal{P}\),\@
and for each satisfying assignment \(\varphi\) of \(\mathcal{P}\),
there is at least one extension of \(\varphi\) to \(V'\) which
is a satisfying assignment for \(\mathcal{P}'\)\@.

Note that this reduction preserves the existence of an satisfying assignment
but does not necessarily preserve the number of satisfying assignments.

\begin{cor}
For any \(\relset'\) a finite subset of \(\clone{\relset}\),
the problem CSP\((\relset')\) is polynomial time reducible to the problem CSP\((\relset)\);
consequently, the complexity of the problem CSP\((\relset)\) only depends on the \(Pol(\relset)\)\@.
\end{cor}

\begin{conj} [Feder and Vardi 1998 \cite{cspconj}]
For any constraint language \mrelset, CSP(\mrelset) is either polynomial time solvable or NP-complete.
\end{conj}

Bulatov and Valeriote \cite{recent08} have a survey of results on the relation between complexity of CSP(\mrelset) and \(Pol(\relset)\). There are more results in \cite{dur628, valeriote}; however,
the CSP dichotomy still remains an open problem. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exact Counting}
In the previous section we mentioned the relation between polymorphisms and complexity of
the problem CSP(\mrelset); in this section we will establish a similar connection 
between polymorphisms and complexity of \ccsp(\mrelset) and mention 
results on the complexity of \ccsp(\mrelset)\@.

Consider the following problem:

\pdef{\cdcol}
{A graph \(G\)}
{The number of 2-Colorings of \(G\)}

The problem \cdcol\  can be solved in polynomial time as follows.
For an input graph \mG, if \mG\ is not bipartite then the answer will be \(0\); otherwise,
if \mG\ is connected then the answer will be 2 and if \mG\ is not connected
there are 2 choices for each component; hence, if \mG\ has \(m\)
connected component the answer will be \(2^m\)\@.

The problem \cdcol\  can be expressed as \ccsp(\(NEQ_{01}\)), where
\(NEQ_{01}\) is the inequality relation over a two element set, that is,
\(NEQ_{01}=\setof{(0,1),(1,0)}\)\@. 
The problem \cdcol\ is easy to solve because
the \(NEQ\) relation belongs to a family of relations called \emph{affine} relations.
A relation is affine if it is expressible by a system of linear equations over a
finite field. The relation \(NEQ_{01}\) is an 
affine relation because \(NEQ_{01} = \{(x,y)\mid x\oplus y \equiv 1 \pmod{2}\}\)\@.

\begin{example}
Relation \mR\ defined as \(R=\setof{(0,1),(1,0),(2,2)}\) is affine because it can be expressed as 
\(\setof{(x,y)\mid x \oplus y \equiv 1 \pmod{3}}\)\@.
\end{example}

For any affine relation \mR, the problem \ccsp(\mR) can be solved in polynomial time
as follows. If the system of linear equations is inconsistent
then there is no solutions; otherwise, there are \(k^m\) solutions where \(m\) is the
dimension of the solution space of the system of linear equations and
\(k\) is the size of the finite field used to express \mR\@.

The simplest type of constraint languages are those 
over a domain of size two. They are usually 
referred to as \emph{Boolean} constraint languages.
\ccsp(\mrelset) for Boolean \mrelset\ is often referred as Boolean \ccsp(\mrelset)\@.
Creignou and Hermann proved a dichotomy for the Boolean problem \ccsp(\mrelset).

\begin{theorem} [Creignou and Hermann 1996 \cite{Nadia}] 
For a Boolean constraint language \mrelset,
if  \mrelset\ is affine then \ccsp(\mrelset) 
is polynomial time solvable; otherwise, it is \cpc\@.
\end{theorem}

Previously, we mentioned the dichotomy theorem for complexity of \ccsp\ in  Section~\ref{sec:appl}.

\begin{theorem} [Dyer and Greenhill 2000 \cite{Dyer}] \label{thm:homd}
For a graph \mH, if each component of \mH\ is a complete reflexive graph
or a complete irreflexive bipartite graph then the problem \chom(\mH)  
is polynomial time solvable; otherwise, it is \cpc\@.
\end{theorem}

Creignou and Hermann \cite{Nadia} proved that a Boolean constraint language \mrelset\
is affine if and only if every relation \mR\ in \mrelset\
is closed under the function \(f(x,y,z)=x\oplus y \oplus z\). It is also easy to see that
a graph \mG\ is complete reflexive if and only if the edge set of \mG\ is closed under any
polymorphism. Similarly, a bipartite graph \(G\) is complete if and only if the orientation
of edges
of \(G\) from one part to other part is closed under any polymorphism.

Hence, polymorphisms can also express criteria used in both theorems. This suggests
that \(Pol(\relset)\) can express the complexity of the problem \ccsp(\mrelset).
Suppose \(\relset_1\) and \(\relset_2\) are two constraint languages such that
every relation in \(\relset_2\) is pp-definable in \(\relset_1\); 
the pp-definition suggests a reduction from CSP(\(\relset_2\))
to CSP(\(\relset_1\))\@. However, this reduction is not usable for counting problems. 
Bulatov and Dalmau provided a reduction that relates 
the complexity of the problem \ccsp(\mrelset) to \(Pol(\relset)\)\@.

\begin{theorem}[Bulatov, Dalmau 2007 \cite{bulatov07}] 
For a constraint language \mrelset\ and a relation \(R\) with the same domain,
if \mR\ is pp-definable in \mrelset\ then \ccsp\((\relset)\) is polynomial-time equivalent 
to \ccsp\((\relset \cup \setof R)\)\@.
\end{theorem}

This theorem is analogous to Theorem~\ref{trm:jeavons}. In the same manner Jeavons's theorem
links complexity of CSP(\mrelset) to clones, this theorem
links complexity of \ccsp(\mrelset) to clones, as well. This connection
led to a dichotomy for the problem \ccsp(\mrelset)\@.

Let \mrelset\ be a constraint language with domain \mD\ and 
let \mR\ be a \(k\)-ary relation on \mD\ pp-definable in \mrelset\@.
A \emph{congruence} of \mR\ is a \(2k\)-ary relation \(Q\) on \mD\ 
which is also pp-definable in \mrelset\
and satisfying the following conditions:
\begin{inparaenum}[(a)]
\item \(Q\) can be viewed as a binary relation on \mR, i.e., \(Q \subseteq R^2\);
\item \(Q\) viewed as a binary relation on \mR\ is an equivalence relation.
\end{inparaenum}


Now, let \(Q,Q_1,Q_2\) be congruences of \mR\ such that
\(Q\subseteq Q_1,Q_2\). Let \(A_1,\dotsc,A_m\) and \(B_1,\dotsc,B_n\) be
the equivalence classes of \(Q_1\) and \(Q_2\), respectively. 
\(M(R;Q_1,Q_2;Q)\) denotes an \(m\times n\) matrix where \(M_{ij}\) is the number of \(Q\)-classes in
\(A_i\cap B_j\). 

A constraint language \mrelset\ is said to be \emph{congruence
 singular} if for any pp-definable relation \mR\ in \mrelset\ and any congruences
\(Q,Q_1,Q_2\) of \mR\ with \(Q\subseteq Q_1,Q_2\), the
\emph{row rank} of  matrix \(M(R;Q_1,Q_2;Q)\) equals
the number of classes of the smallest equivalence relation containing
both \(Q_1\) and \(Q_2\)\@. 

\begin{theorem}[Bulatov 2008 \cite{Bulatov}]
For a constraint language \mrelset,
the problem \ccsp(\mrelset) is polynomial time solvable if 
\mrelset\ is congruence singular; otherwise, it is \cpc\@.
\end{theorem}

Bulatov proved a dichotomy for all \mrelset\ but the decidability of being congruence
singular remained open until Dyer  and Richerby \cite{DyerR10} 
proved that being congruence singular can be verified in polynomial time.

\begin{theorem} [Dyer and Richerby 2010 \cite{DyerR10}]
For a constraint language \mrelset, checking if \mrelset\ is congruence singular is in NP.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Weak Co-clones}
In the previous section, we showed that 
complexity of the problems CSP(\mrelset) and \ccsp(\mrelset) depends on \(Pol(\relset)\)\@.
Because of usage of existential quantifier in pp-definition,
it is very unlikely that
complexity of approximating the problem \ccsp(\mrelset) depends on \(Pol(\relset)\).
However, for the approximating the problem \ccsp(\mrelset), we can use
simpler tools. Pp-definitions without existential quantifier only imply
parsimonious reductions which preserve approximation.

For a domain \mD, any set of relations closed under conjunctions and
containing \(EQV_D\), the binary equality relation over \mD,
is a weak co-clone. For a constraint language \mrelset, 
\(\wclone{\relset}\) is the least weak co-clone containing \mrelset,
also called the weak co-clone generated by \mrelset\@.

For a partial function \(f\) on the domain \mD,
the set of all tuples from \(D^n\) on which \(f\) is
defined is called the \emph{domain} of \(f\) and denoted by \(\dom(f)\).
A set of partial functions \(C\) is said to be \emph{down-closed} if
for every function \(f\) in \(C\), \(C\) contains any function \(f'\) such that
\(\dom(f')\subseteq\dom(f)\) and \(f'(a_1,a_2,\dotsc,a_n)=f'(a_1,a_2,\dotsc,a_n)\)
for every tuple \((a_1,a_2,\dotsc,a_n)\in \dom(f')\)\@.
A down-closed set of partial functions, 
containing all projections and closed under 
superpositions is called a \emph{partial clone}. 

Let \mR\ be a relation with domain \(D\) and \(f:D^n\to D\) be a partial function of arity \(n\)
over the same domain.
Function \mf\ is a \emph{partial polymorphism} for \mR,
if for any \mn\ tuples \(\ba_1,\ba_2,\dotsc,\ba_n\) in \mR\, 
if  \((\ba_1,\ba_2,\dotsc,\ba_n) \in dom(f)\) then 
\(f(\ba_1,\ba_2,\dotsc,\ba_n)\) is also in \mR\@. Relation \mR\ in this case is said to
be \emph{invariant} with respect to \mf\@.
The set of all partial polymorphisms of a constraint language \mrelset\ is denoted by
\(pPol(\relset)\) and the set of all relations invariant under a set of partial functions
\(C\) is denoted by \(Inv(C)\)\@. Note that the \(Inv\) function for partial functions is
an extension of the \(Inv\) function for total functions.

\begin{theorem} [Creignou et al. \cite{madu}] \label{trm:partial}
Let \(\relset_1\),\(\relset_2\) be two sets of relations over the same domain; if 
\(\relset_2\) is a finite subset of \(\wclone{\relset_1}\) then
\ccsp(\(\relset_2\)) is parsimoniously reducible to \ccsp(\(\relset_1\))\@.
\end{theorem}

Fleischer and Rosenberg \cite{Rosenberg} proved that for any constraint language \mrelset\
and any set of functions \(C\),
we have \(Inv(pPol(\relset))=\wclone{\relset}\) and
\(pPol(Inv(C))=\wclone{C}\)\@. On the other hand, \(pPol\) and \(Inv\) functions 
maintain extensivity and antitony; hence, they form Galois connection between 
sets of relations and partial functions. Due to properties of Galois connections,
for any constraint language \mrelset\ and any set of functions \(C\), the 
sets \(Inv(C)\) and \(pPol(\relset)\) are a weak co-clone and a partial clone, respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Approximate Counting} \label{chp:approx}
In this chapter we formally define the complexity class which
is considered as the efficient computational model for counting problems.
We define AP-reductions and give a classification of computational problems 
with respect to AP-reductions. We use the definition of FPRAS from \cite{counting}\@. 

A \emph{randomized approximation scheme} (RAS) for a function \(f:\Sigma^*\to\nat\)
is a probabilistic algorithm that for an input \((x,\eps)\in\Sigma^*\times(0,1)\) 
where \(x\) is an instance of \mf\ and \(\eps\) is the error tolerance, 
produces an integer random variable \(z\) such that 
\[Pr\left(\left|\frac{z-f(x)}{f(x)}\right|\le \epsilon\right) \ge \frac{3}{4}.\]
A randomized approximation scheme is said to be \emph{fully polynomial} if it runs in time \(poly(|x|,\frac{1}{\eps})\)\@. 
The phrase ``fully polynomial randomized approximation scheme'' is usually abbreviated to 
\emph{FPRAS}\@. The complexity class FPRAS is referred to problems which have FPRAS\@.

Note that there is no significance in the constant \(\frac{3}{4}\) in the definition,
other than being in \((\frac{1}{2},1)\) interval. 
Jerrum et al. \cite{JVV} proved that any success probability 
greater than \(\frac{1}{2}\) can be improved to \(1-\delta\) for any desired \(\delta\) by
\(O(\log \delta^{-1})\) trials of algorithm and taking the median of the results.

APX is another complexity class that is regarded as an efficient computational model for
optimization problems.
For a function \(f:\Sigma^*\to\nat\) and a constant factor \(\alpha\),
\mf\ has an \(\alpha\)-APX if there is an algorithm that
takes \(x\in\Sigma^*\) as an input and in time \(poly(|x|)\) produces an integer \(z\)
such that \(\frac{1}{\alpha}\le\frac{z}{f(x)}\le \alpha\). In the same manner,
poly-APX and log-APX are algorithms that given an input
\(x\), in time \(poly(|x|)\) find a solution \(z\) 
such that  \(\frac{1}{|x|^c}\le\frac{z}{f(x)}\le |x|^c\) for some constant \(c\) and
\(\frac{1}{\log |x|}\le\frac{z}{f(x)}\le \log |x|\), respectively.
There are no results on \ccsp(\mrelset) with
APX schemas. With the next lemma, I explain why APX schemas are not used for problem \ccsp(\mrelset) .

\begin{lemma}
For a constraint language \mrelset, if there is a poly-APX for
the problem \ccsp(\mrelset) then there is an FPRAS it, as well.
\end{lemma}

\begin{proof}
Let \(\apxalg\) be an algorithm and \(T\) be a polynomial function such
that for any instance \(\probi=(D,V,\conset)\)
of \ccsp(\mrelset), we have 
\[\frac{1}{T(|\probi|)} \le \frac{\apxalg(\probi)}{\#\probi} \le T(|\probi|)\]
Choose \(k\) a sufficiently large number whose value
will be determined later. Let \(\probi'=(D, V',\conset')\) be \(k\) copies of \(\probi\) as
\[V'=\{x^i \mid 1 \le i \le k, x \in V\}\] and
\[\conset'=\{\const{(x^i_{l_1},\dotsc, x^i_{l_t}), R} \mid 1 \le i \le k,
\const{(x_{l_1},\dotsc, x_{l_t}), R} \in \conset\}\]
By multiplication principle, \(\#\probi'=\#\probi^k\); \(\sqrt[k]{\apxalg(\probi')}\) is 
an (\(1+\eps\))-approximation for \(\probi\)\@ if \(1+\eps > \sqrt[k]{T(|\probi|\cdot k)}\)\@.
For that, it is sufficient for \(k\) to be greater than
\(\oneoeps\cdot \log T(|\probi|\cdot k)\)\@.
Since the function \(T\) is polynomial in \(|\probi|\), \(k\) is also polynomially 
bounded by \(|\mathcal{P}|\) and \(\oneoeps\)\@.
\end{proof}

\begin{defi}[AP-reduction]
For any two functions \mf\ and \mg, 
an \emph{approximation-preserving reduction}(AP-reduction for short)
from \mf\ to \mg\ is a probabilistic algorithm \(\apxalg\) which uses a solver
\(\apxalg'\) for \mg\ and for any input \((x,\eps) \in \Sigma^*\times(0,1)\) where \(x\)
is an instance of \mf\ and \(\eps\) is an error tolerance, produces an integer random variable \(z\)
satisfying the following  conditions: 
\begin{itemize}
\item \(\apxalg'\) takes an input in the form \((w,\delta) \in \Sigma^*\times(0,1)\)
where \(w\) is an instance of \mg\
and \(\delta\) is the error tolerance,
\item if \(\apxalg'\) meets the specification for being a RAS for 
\mg\ then \(\apxalg\) meets the specifications for being a RAS for \mf, 
\item \(\apxalg\) runs in polynomial time in terms of \(|x|\) and \(\oneoeps\)
\end{itemize}
\end{defi}

If an approximation-preserving reduction from \mf\ to \mg\ exists we write \(f \aple g\)
and say \mf\ is \emph{AP-reducible} to \mg. If \(f \aple g\) and \(g \aple f\)
then we say that  \mf\ and \mg\ are \emph{AP-interreducible} and write \(f \apeq g\)\@. 


In this chapter we will study three major classes of counting problem with respect
to complexity of approximate counting. We will study some of the important counting problem in FPRAS
in Section~\ref{sec:poly}, the problems that are hard to approximate in Section~\ref{sec:hard}, 
and the problem \cbis\ and problems AP-interreducible with it in Section~\ref{sec:bis}\@.
In Section~\ref{sec:other}, we will mention some problems that not known to fit in this classification.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polynomial Time Solvable Problems} \label{sec:poly}
Few non-trivial combinatorial problems involving counting 
can be solved in polynomial time.
Some of these problems are reducible to determinant such as
the problem of finding the number of spanning trees of a graph and 
the problem of finding the number of perfect matchings in a planar graph.
Bulatov \cite{Bulatov} showed that the problem \ccsp(\mrelset) is polynomial time solvable
for congruence singular relations \mrelset\ and otherwise it is \cpc\@.
In this section we show several
examples of counting problems for which an approximate solution can be obtained in polynomial time.

There are some artificial examples of problem \ccsp(\mrelset) that can be approximated 
in polynomial time. 

\begin{example} \label{exm:poly}
For the graph \mH\ shown in Figure~\ref{fig:approxible},
we show that the problem \chom(\mH) is in FPRAS\@. Suppose the input is 
\((G,\eps)\) where \mG\ is a connected graph with \mn\ vertices and \(\eps\)
is the error tolerance.
We know that 
\(4^n\le hom(G,H) \le 4^n+3^n\)\@.
For \(\eps \ge (\frac{3}{4})^n\), take \(4^n\) as an approximation, the error ratio will  be
\[\frac{\hom(G,H)-4^n}{\hom(G,H)} \le \frac{3^n}{\hom(G,H)} \le (\frac{3}{4})^n \le \eps\]
For \(\eps < (\frac{3}{4})^n\), we have \(\oneoeps>(\frac{4}{3})^n \);
hence, \((\oneoeps)^{\log_{\frac{4}{3}}3} > 3^n\); consequently, \(3^n\) is polynomial 
in terms of \(\oneoeps\); which means the number of 3-colorings of \mG\ can be evaluated in 
\(poly(n,\oneoeps)\) time. 
Note that \(hom(G,H)\) is \(4^n\) plus the number of 3-colorings of \mG\@.

\begin{figure}[h] 
\center\input{figs/approxible.pdftex}
\caption{Graph \ensuremath{G} used in Example~\ref{exm:poly}}
\label{fig:approxible}
\end{figure}
\end{example}

The construction in Example~\ref{exm:poly} shows that for any graph \mG,
there exists a graph \mH\ such that \mG\
is an induced subgraph of \mH\ and the problem \chom(\mH) is in FPRAS\@.
In other words, although \mG\ is an induced subgraph of \mH, approximating
the problem \chom(\mH)
may be easier than approximating the problem \chom(\mG)\@.

Another interesting counting problem which can be approximated in polynomial time is 
the problem \pname{\#DNF-SAT} defined as
\pnndef %{\pname{\#DNF-SAT}}
{A Boolean DNF (Disjunctive Normal Form) formula \(\varphi\)}
{The number of satisfying assignments for \(\varphi\)}

There are different algorithms to solve this problem.
Luby and Veli\v{c}kovic \cite{Luby} provided a deterministic algorithm for
approximating the probability of a random assignment being satisfying. 
Madras et al. \cite{Madras} provided a Monte-Carlo algorithm
for this problem. Jerrum et al. \cite{JVV} provided an algorithm,depicted in Algorithm~\ref{alg:dnf},
for sampling the problem \pname{DNF-SAT}. 
\begin{algorithm}[h]
\begin{algorithmic}
\WHILE {true}
       \STATE Select a clause \(C\) randomly with probability proportional to the size of the clause
       \STATE Select an assignment \(A\) satisfying \(C\) uniformly at random
       \STATE Let \(N\) be the number of clauses satisfied by \(A\)
       \STATE With probability \(\frac{1}{N}\): output \(A\) and halt
\ENDWHILE
\end{algorithmic}
\caption{An algorithm for sampling \pname{DNF-SAT}}\label{alg:dnf}
\end{algorithm}

Since the problem \pname{\#DNF-SAT} is self-reducible, Theorem~\ref{thm:selfred} implies
that Algorithm~\ref{alg:dnf} can be used to find an approximate solution for\pname{DNF-SAT}\@.

Other common method used to approximate counting problems is using the Markov chain
Monte-Carlo algorithms. Consider the following problems:

\pdef{\pname{\#Match}}
{A graph \mG}
{The number of matchings in \mG}

\newcommand{\ldkcol}{\#\pname{LowDegree}-k-\pname{Coloring}}
\pdef{\ldkcol}
{A graph \mG\ such that \(2\Delta(G)+1\le k\), where \(\Delta(G)\)
is the maximum degree in \mG}
{The number of proper k-Colorings of \mG}

Jerrum and Sinclair \cite{Jerrum96} used Markov chain Monte-Carlo method 
to approximate the problem \pname{\#Match}; Jerrum \cite{Jerrum} used the same method 
to approximate the problem \ldkcol\ for graphs 
with bounded degree. We give a brief description of the Markov chain Monte Carlo method
and show how these two problems are solved using this method.

The Markov chain Monte Carlo method solves a sampling problem as follows.

a Markov chain is finite automaton in which the transition between the states are labeled 
with probabilities of transition between the states. \(X_t\) is used to denote
the state of the automaton at step \(t\)\@.
Consider a Markov chain with state space \(\Omega\) and stationary distribution \(\pi\)\@.
Intuitively, a Markov chain is said to be \emph{ergodic} if regardless of the initial state,
the probability distribution over \(\Omega\) asymptotically converges to \(\pi\)\@.
In order to sample, start from an arbitrary state in \(\Omega\); simulate the
Markov chain for \(T\) steps; finally output the final step.
The number \(T\) should be chosen sufficiently large so that after \(T\) steps,
the distribution of state
is arbitrarily close to the desired distribution \(\pi\)\@. The number of steps required
for the algorithm to become close enough to \(\pi\) is called the \emph{mixing time}\@.
Loosely, if the mixing time for a Markov chain is polynomial in terms of the size of the input
and the desired approximation ratio, then the Markov chain is \emph{rapidly mixing}\@.

The problem \ldkcol\ is solved as follows.
Let \mG\ be the input graph with \mn\ vertices
and \mm\ edges. Consider a sequence of subgraphs of \mG\ such that 
\(G_m=G\) and \(G_i\) is obtained from \(G_{i+1}\) by removing an arbitrary edge.
For any graph \mG, let \(\Omega_k(G)\) denote the set of k-colorings of \mG\@.
The general idea is using the following formula to estimate \(|\Omega_k(G)|\):
\[ |\Omega_k(G)| = 
\frac{|\Omega_k(G_m)|}{|\Omega_k(G_{m-1})|} \times 
\frac{|\Omega_k(G_{m-1})|}{|\Omega_k(G_{m-2})|} \times 
\dotsb \times
\frac{|\Omega_k(G_1)|}{|\Omega_k(G_0)|} \times 
|\Omega_k(G_0)|
\]
Trivially, \(|\Omega_k(G_0)| = k^n\)\@. All that 
remains is estimating the ratios \(\varrho_i\) defined as
\[\varrho_i=\frac{|\Omega_k(G_i)|}{|\Omega_k(G_{i-1})|}\]
for all values of \(i\) in the range \(1\le i \le m\)\@.

Let \(M(G_i, k)\) denote a Markov chain whose state space is \(\Omega_k(G_i)\)\@. The transition probabilities from the state \(X_t\) are modeled as 
\begin{enumerate}[i)]
\item choose a vertex \(v\) and a color \(c\) uniformly at random
\item recolor the vertex \(v\) with the color \(c\); if the resulting coloring \(X'\)
is proper then let \(X_{t+1}=X'\); otherwise, let \(X_{t+1}=X_t\)\@.
\end{enumerate}

Jerrum \cite{Jerrum} showed that for \(k \ge \Delta(G) + 2\), the \(M(G_i,k)\) is ergodic and 
rapidly mixing with a uniform stationary distribution. For \(X\in \Omega_k(G_{i-1})\),
let \(Z_i(X)\) be \(1\) if \(X\in \Omega_k(G_i)\); otherwise, \(0\)\@.
Jerum also proved that by a high probability the expected value of 
\(Z_i(X)\) over polynomial number of samples is an
acceptable estimation for \(\varrho_i\)\@.

The general idea to solve the problem \pname{\#Match} is similar. Jerrum and Sinclair \cite{Jerrum96}
solved a weighted version of the problem \pname{\#Match} which is called the problem 
\pname{Monomer-Dimer} in statistical physics. It is defined as follows.

\pdef{Monomer-Dimer}
{A graph \mG\ and a positive real number \(\lambda\)}
{The partition function \(Z_G(\lambda)\) which is the sum of
\(\lambda^{|M|}\) for all matchings \(M\) of \mG}

Note that \(Z_G(1)\) is the number of matchings in \mG\ and \(Z_G(0)=1\) because
for the empty matching \(M\), \(\lim_{\lambda\to 0^+}\lambda^{|M|}=1\). The technique used to
solve this problem is the same as the problem \ldkcol; however, instead of removing edges from
the graph, the sequence is obtained by reducing the value of \(\lambda\)\@. We will not 
go through details about this algorithm.

We defined the Ising model in Section~\ref{sec:appl}\@. 
Jerrum and Sinclair \cite{Jer93} have proved that there exists an FPRAS for the
problem of computing the partition function in Ising model if the model 
is consistent.

\begin{comment}
Consider a Markov chain with each state representing a solution of the problem.
The transitions are to the same solution with probability of \(\frac{1}{2}\) 
and to a similar solution with probability \(\frac{1}{2}\).

There is usually a sequence of instances (the length of sequence is polynomial) such that
the first element of the sequence is the instance  that we are trying to solve
and the last element is a trivial instance.
The ratio of answers between two consecutive elements 
is estimated by sampling along a random walk.
The final answer is the product of the ratios and the answer for trivial instance. 

In order for Markov chain Monte-Carlo to work, the chain must be ergodic and rapidly mixing.
Mixing time is the minimum length of a random walk such that the required
quantity is measured with desired approximation and if mixing
time is polynomial then the chain is said to be rapidly mixing.

The problem \pname{\#Match} is solved as follows.
A suitable sequence \(\bl\) of real numbers beginning with one and ending
with zero is chosen. The ratios \(Z_G(\bl_i)/Z_G(\bl_{i+1})\) are estimated 
by sampling along a random walk on the Markov chain. \(Z_G(1)\) is the product of
all the ratios.

The \ldkcol\ problem is solved as follows. Let \mG\ be a graph with \mn\ vertices
and \mm\ edges. Let \(\bG\) be a sequence of subgraphs of \mG\ where
\(\bG_0=G\) and \(\bG_{i+1}\) is obtained from \(\bG_i\) by removing a single edge. 
The last element \(\bG_m\) is an empty graph which is k-colorable in \(k^n\) ways.
The ratio \(Z(G_i)/Z(G_{i+1})\) is estimated
by sampling along a random walk on the Markov chain. \(Z(G)\) is the product of all the
ratios and the number of k-colorings of \(\bG_m\).
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problems Hard To Approximate} \label{sec:hard}
In this section we study the set of counting problems that are the hardest problems in \cp\
for the complexity of approximation. In other words every
problem in \cp\ is AP-reducible to them.
Existence of an FPRAS for any of these problems implies NP = RP where 
a problem is in RP if there is a randomized algorithm that runs in polynomial time
and if the answer is NO always rejects and if the answer is YES accepts
with probability of at least \(\frac{3}{4}\). The following theorem 
points us to the first set of problems in this complexity class.

\begin{theorem} [Goldberg et al. \cite{Leslie03}] \label{thrm:npcp}
For any NP-complete decision problem, the corresponding counting problem is complete
for \cp\ with respect to AP-reducibility.
\end{theorem}

\begin{cor}
\csat, \ctsat, and \ctcol\ are complete for \cp\ with respect to AP-reducibility.
\end{cor}

Another important problem AP-interreducible with the problem \csat\ is
the problem \cisp\ defined as:

\pnndef%{\cisp}
{A graph \mG}
{The number of independent sets in \mG}

The decision problem IS is a trivial problem; every graph has at least an
empty independent set.
However, the counting problem \cisp\ is proved to be AP-interreducible with the problem \csat\ 
by Goldberg et al.\cite{Leslie03}\@.
Finding AP-reductions from many problems from the problem \cisp\ is more straightforward than
finding reductions from the problems that the decision version is NP-complete.

\begin{figure}[h]
\centering 
\subfigure[\ensuremath{Wr_0}]{\input{figs/Wr0.pdftex}\label{fig:Wr0}}\hspace{4.78cm}
\subfigure[\ensuremath{Wr_1}]{\input{figs/Wr1.pdftex}\label{fig:Wr1}}\\
\subfigure[\ensuremath{Wr_2}]{\input{figs/Wr2.pdftex}\label{fig:Wr2}}\hspace{4cm}
\subfigure[\ensuremath{Wr_3}]{\input{figs/Wr3.pdftex}\label{fig:Wr3}}
\caption{Wrench graphs Family}
\label{fig:wrench}
\end{figure}

\begin{example}
Consider the binary relations OR and NAND  on domain \(\setof\zo\) defined as
\(\mathrm{OR}=\setof{(0,1),(1,0),(1,1)}\) and \(\mathrm{NAND}=\setof{(0,0),(0,1),(1,0)}\)\@.
For an instance \(G = (V,E)\) of the problem \cisp, consider
an instance \(\probi=(\setof\zo,V,\conset)\)
of the problem \ccsp(OR) where \[\conset = \{\const{(x,y), \mathrm{OR}} \mid xy \in E\}.\]
Every independent set \(I\) in \mG, corresponds to an assignment \(\varphi\)
for \(\probi\) where \(\varphi(x) = 0\) if \(x\in I\) and \(\varphi(x)=1\) if \(x\notin I\)\@.
Similarly, the problem \cisp\ can be expressed by the \ccsp(NAND) as well;
hence, the problems \ccsp(OR) and \ccsp(NAND) are both AP-interreducible with the
problem \csat\@.

Although the problem \dsat\ (the decision problem) is polynomial time
solvable, the problem \cdsat\ can express \ccsp(OR) and
\ccsp(NAND); hence, the problem \cdsat\ is also AP-interreducible with the problem \csat\@.
\end{example}

\begin{example}[\sc\#Wrench-Col] \label{exm:wrench}
The Wrench graphs family are denoted by \(Wr_q=(V_q, E_q)\) where \(V_q=\{a,b,c_1,c_2,\dotsc,c_q\}\)
and \(E_q=\setof{\setof{a,b},\setof{b,b}} \cup 
\setof{\setof{b,c_i},\setof{c_i,c_i}:1\le i\le q}\)\@.
Graphs \(Wr_0\), \(Wr_1\), \(Wr_2\), and \(Wr_3\) are shown in Figure~\ref{fig:wrench}.
The problem \chom(\(Wr_q\)) is referred to as the problem \#q-{\sc Wrench-Col}. 
Goldberg et al. \cite{Leslie03} proved that for \(q\neq 2\), the problem\#q-{\sc Wrench-Col} 
is AP-interreducible with the problem \csat\@.
\end{example}

\begin{example} [\#q-\pname{Particle-WR-Configs}] \label{exm:particles}
For \(q \ge 1\), homomorphisms to \(S^*_q\) where
\(S^*_q\) is a q-leaf star with loops at all the \(q+1\)
vertices are configuration in the q-particle Widom-Rowlinson model.
The problem \#q-\pname{Particle-WR-Configs} is defined as the problem \chom(\(S^*_q\)).
Graphs \(S^*_1\), \(S^*_2\), \(S^*_3\), and \(S^*_4\) are shown in Figure~\ref{fig:wrconfigs}.
 
The problem \chom(\(S^*_1\)) is polynomial time solvable.
We will consider the problems \chom(\(S^*_2\)) and \chom(\(S^*_3\)) later;
Goldberg et al. \cite{Leslie03} have proved that 
for \(q \ge 4\), the problem \chom(\(S^*_q\)) is AP-interreducible with the problem \csat\@.
\end{example}

\begin{figure}[h]
\centering 
\subfigure[\ensuremath{S^*_1}]{\input{figs/wr1.pdftex}\label{fig:ss1}}\hspace{5cm}
\subfigure[\ensuremath{S^*_2}]{\input{figs/wr2.pdftex}\label{fig:ss2}}\\
\subfigure[\ensuremath{S^*_3}]{\input{figs/wr3.pdftex}\label{fig:ss3}}\hspace{5cm}
\subfigure[\ensuremath{S^*_4}]{\input{figs/wr4.pdftex}\label{fig:ss4}}
\caption{Particle-WR-Configs}
\label{fig:wrconfigs}
\end{figure}

We defined the Ising and Potts models in Section~\ref{sec:appl}\@.
Jerrum and Sinclair \cite{Jer93} showed that the problem of computing
the partition function in Ising model is AP-interreducible with the \csat\ problem
if the model is not consistent.

Jerrum and Goldberg \cite{Goldberg2007} showed that the problem of computing 
the partition function in Potts model with more that two states is
AP-interreducible with the \csat\ problem. They also showed that the problem of computing
the partition function in Ising model is AP-interreducible with the problem \csat\
if the model is not ferromagnetic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problems AP-interreducible With \cbis} \label{sec:bis}
The proof used in \cite{Leslie03} to show that the \csat\ problem is AP-reducible
to the problem \cisp\ does 
not work if the input for the problem \cisp\ is limited to bipartite graphs.
The version of the problem \cisp\ with input limited to bipartite graphs is called
the problem \cbis\ and is defined as follows:

\pnndef%{\cbis}
{A bipartite graph \mG}
{The number of independent sets in \mG}

Note that by Theorem~\ref{thm:homd} exactly solving the problem \cbis\ is \cpc\@.
Goldberg et al.~\cite{Leslie03} proved that the following problems are AP-interreducible with \cbis\@.

\begin{figure}[h]
\centering
\subfigure[\ensuremath{\vec{P}^*_2}]{\input{figs/ds.pdftex}\label{fig:ds}}\hfill 
\subfigure[\ensuremath{P_4}]{\input{figs/p4.pdftex}\label{fig:p4}}\hfill
\subfigure[Oriented \ensuremath{P_4}] {\input{figs/dp4.pdftex}\label{fig:dp4}}\\
%\subfloat[$P^*_4$]{\input{figs/ps4.pdftex}\label{fig:ps4}}\hfill
\subfigure[\ensuremath{\vec{P}^*_3}]{\input{figs/dps3.pdftex}\label{fig:dps3}}\hfill
\subfigure[\ensuremath{P^*_k}]{\input{figs/psk.pdftex}\label{fig:psk}}
\caption{Several graphs AP-interreducible with \cbis}
\label{fig:bisred}
\end{figure} 

\pdef{\cdsp}
{A partial order \((P,\preceq)\)}
{The number of down-sets in \(P\)}

In a partial order \(P=(X,\preceq)\), a down-set (also called lower-set) is a set \(D\) such that 
for every \(x\in D\) if there exist \(y \preceq x\) then \(y\in D\), as well.
Note that the number of down-sets in a partial order equals
the number of anti-chains in the same partial order. 

\pdef{\pname{\#1P1N-SAT}}  
{A Boolean CNF formula \(\varphi\) with clauses of size one, or size two such that
there is one negative and one positive literal per clause}
{The number of satisfying assignments of \(\varphi\)}


For many graphs, the problem \chom(\mH) is also AP-interreducible with the problem \cbis\@.
For example, the problem \chom(\mH) is AP-interreducible with the problem \cbis\ 
if \mH\ is any of the graphs \(\vec{P}^*_2\), \(P_4\), \(\vec{P}_4\), \(\vec{P}^*_3\),
or \(P^*_k\)(\(k\ge 3\)), which are shown in Figure \ref{fig:bisred}\@.
 
There are also problems from statistical physics that are AP-interreducible with the problem \cbis\@.
The Ising model is described in Section~\ref{sec:appl}.
The problems \pname{\#2-Wrench-Coloring}
and \pname{\#2-Particles-WR-Configs} are described in Examples~\ref{exm:wrench}~
and~\ref{exm:particles}, respectively.

\pdef{\pname{Ferromagnetic Ising}}
{A graph \mG, inverse temperature \(\beta\), interaction strengths \(J\) such that
\(J_{u,v} > 0\), local external magnetic field \(l\)}
{The partition function \(Z(G,\beta,J,l)\)}

\pdef{\pname{\#2-Wrench-Coloring}}
{A graph \mG}
{The number of homomorphisms from \mG\ to \(WR_2\)}

\pdef{\pname{\#2-Particles-WR-Configs}}
{A graph \mG}
{The number of homomorphisms  from \mG\ to \(S^*_2\)}

Goldberg and Jerrum \cite{Goldberg2007} proved that the problem \pname{Ferromagnetic Ising} 
is AP-interreducible with the problem \cbis\ and 
Goldberg et al.~\cite{Leslie03} proved that the problems \pname{\#2-Wrench-Coloring} and
the \pname{\#2-Particles-WR-Configs} are  AP-interreducible with the problem \cbis\@.

Here we prove that the two characterizing problems in this class, i.e., \cbis\ and \cdsp,
are AP-interreducible.
\begin{lemma} \label{lem:dstobis}
\cdsp\ \(\aple\) \cbis\@.
\end{lemma}

We use the proof from \cite{counting}\@. We denote the number of down-sets in a partial order 
\(P\) by \(\cds(P)\) and the number of independent sets in a graph \mG\ by
\(\cis(G)\)\@.
\begin{proof}
Let \(P=(X=[n],\preceq)\) be an instance of the problem \cdsp\@. 
Let \(B=(U,V,E)\) be a bipartite graph defined as follows.
For \(i\) in \(X\), let \(U_i\) and \(V_i\) be a collection of disjoints sets of
size \(2n\)\@. Then, take \(U=\bigcup_{1 \le i \le n} U_i\), \(V=\bigcup_{1 \le i\le n} V_i\), and
\[E = \{uv \mid u \in U_i \land v \in V_j \land i \preceq j\}.\]

An independent set \(I\) in \(B\) is said to be \emph{full} if for all \(1 \le i \le n\)
the set \(I\cap (U_i \cup V_i)\) is nonempty. Every full independent set \(I\) in \(B\)
corresponds to the down-set \(D=\{i \mid I \cap V_i \neq \emptyset\}\) in \(P\)\@.
In the same manner, every down-set \(D\) in \(P\) gives exactly \((2^{2n}-1)^n\) full independent
sets in \(B\)\@. Note that \(2^{2n}-1\) is the number of nonempty subsets of \(U_i \cap V_i\)\@.

On the other hand the number of non-full independent sets in \(B\) is less than
\(3^n(2^{2n}-1)^{n-1}\)\@. Thus, for \(n\ge 5\) we have 
\[\cds(P) = \left\lfloor\frac{\cis(P)}{(2^{2n}-1)^n} \right\rfloor .\]
\end{proof}

\begin{lemma} \label{lem:bistods}
\cbis\ \(\aple\) \cdsp\@.
\end{lemma}

The proof used in \cite{counting} involves reduction to several other problem. Here 
we present our own proof which is the special case of Theorems we will be using in
Chapter~\ref{chp:results}\@.

\begin{proof}
Let \(B=(U,V,E)\) be a bipartite graph. We will create a partial order \(P=(X,\preceq)\)
such that \(\cis(B)=\cds(P)\)\@. Take \(X=U \cup V\) and \(u \preceq v\) if and only if
\(uv \in E\)\@. We claim that for every down-set \(D\) in \(P\), 
\(I=(U\cap D) \cup (V - D)\) is an independent set and for any independent set
\(I\) in \(B\) the set \(D=(U \cap I) \cup (V - I)\) is a down-set in \(P\)\@.

Let \(D\) be a down-set in \(P\)\@. Since \(U\cap D\) and \(V - D\) are subsets of
\(U\) and \(V\) respectively, they are both independent sets.
There is no edge from \(V\) to \(U\) and since \(D\) is a DownSet
all the neighbors of \(U\cap D\) rely in \(V\cap D\)
and none of them are in \(V - D\); hence, the set \(I=(U\cap D) \cup (V - D)\) is
an independent set in \(B\)\@. On the other hand, let \(I\) be an independent set in \(B\)\@.
There is no out-going edge from any vertex in \(V\) and since \(I\) is an independent set
out-neighbors of \(U\cap I\) are limited to \(V - I\); hence, the set \(D=(U \cap I) \cup (V - I)\) is
a down-set in \(P\)\@.

Hence, we have a parsimonious reduction from the problem \cbis\ to the problem \cdsp\@.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other Difficult Problems} \label{sec:other}
Goldberg et al.~\cite{Trichotomy} proved an approximation trichotomy for the Boolean problem
\ccsp(\mrelset). A Boolean relation \mR\ is \emph{monotone} if \mR\ is closed under
\(\land\) and \(\lor\) operators; a Boolean constraint languages \mrelset\ is monotone if 
every relation in \mrelset\ is monotone.


\begin{theorem}[Dyer, Goldberg, Jerrum, 2007 \cite{Trichotomy}] \label{thrm:trichotomy}
For a constraint language \mrelset,
if \mrelset\ is affine then \ccsp(\mrelset) is polynomial time solvable; otherwise,
if \mrelset\ is monotone then it is AP-interreducible to the problem \cbis; otherwise,
it is AP-interreducible with the problem \csat\@.
\end{theorem}

Despite the approximation trichotomy for the Boolean problem \ccsp(\mrelset),
the non-Boolean problem \ccsp(\mrelset) seems to have more complexity classes.
So far, our knowledge on complexity classes of the problem \ccsp(\mrelset) 
is very limited. We are not aware if the approximation
complexity classes for this problem are finite or even countable.
We know a few problems that are only proven to be harder than
the problem \cbis\ \cite{Leslie03} and currently, 
we have no knowledge on how hard these problems are.

Here are some of these problems. \pname{\#3-Particles-WR-Configs} was introduced in
Example~\ref{exm:particles}.

\pdef{\pname{\#3-Particles-WR-Configs}}
{A graph \mG}
{The number of homomorphisms from \mG\ to \(Wr_3\)}

\pdef
{\pname{\#Bipartite} q-\pname{Coloring} for \(q\ge 3\)}
{A bipartite graph \mG}
{The number of q-Colorings of \mG}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\nocite{*}
